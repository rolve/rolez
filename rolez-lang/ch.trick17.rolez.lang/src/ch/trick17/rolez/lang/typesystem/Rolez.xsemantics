import ch.trick17.rolez.lang.RolezExtensions
import ch.trick17.rolez.lang.RolezUtils
import ch.trick17.rolez.lang.rolez.Argumented
import ch.trick17.rolez.lang.rolez.ArithmeticBinaryExpr
import ch.trick17.rolez.lang.rolez.Assignment
import ch.trick17.rolez.lang.rolez.Block
import ch.trick17.rolez.lang.rolez.BooleanLiteral
import ch.trick17.rolez.lang.rolez.Cast
import ch.trick17.rolez.lang.rolez.CharLiteral
import ch.trick17.rolez.lang.rolez.Class
import ch.trick17.rolez.lang.rolez.ClassRef
import ch.trick17.rolez.lang.rolez.Constr
import ch.trick17.rolez.lang.rolez.DoubleLiteral
import ch.trick17.rolez.lang.rolez.EqualityExpr
import ch.trick17.rolez.lang.rolez.Expr
import ch.trick17.rolez.lang.rolez.ExprStmt
import ch.trick17.rolez.lang.rolez.GenericClassRef
import ch.trick17.rolez.lang.rolez.IfStmt
import ch.trick17.rolez.lang.rolez.IntLiteral
import ch.trick17.rolez.lang.rolez.LocalVarDecl
import ch.trick17.rolez.lang.rolez.LogicalExpr
import ch.trick17.rolez.lang.rolez.MemberAccess
import ch.trick17.rolez.lang.rolez.Method
import ch.trick17.rolez.lang.rolez.New
import ch.trick17.rolez.lang.rolez.Null
import ch.trick17.rolez.lang.rolez.NullLiteral
import ch.trick17.rolez.lang.rolez.OpArithmetic
import ch.trick17.rolez.lang.rolez.ParameterizedBody
import ch.trick17.rolez.lang.rolez.Parenthesized
import ch.trick17.rolez.lang.rolez.PrimitiveType
import ch.trick17.rolez.lang.rolez.ReferenceType
import ch.trick17.rolez.lang.rolez.RelationalExpr
import ch.trick17.rolez.lang.rolez.ReturnExpr
import ch.trick17.rolez.lang.rolez.ReturnNothing
import ch.trick17.rolez.lang.rolez.Role
import ch.trick17.rolez.lang.rolez.RoleType
import ch.trick17.rolez.lang.rolez.SimpleClassRef
import ch.trick17.rolez.lang.rolez.Start
import ch.trick17.rolez.lang.rolez.Stmt
import ch.trick17.rolez.lang.rolez.StringLiteral
import ch.trick17.rolez.lang.rolez.SuperConstrCall
import ch.trick17.rolez.lang.rolez.Task
import ch.trick17.rolez.lang.rolez.The
import ch.trick17.rolez.lang.rolez.This
import ch.trick17.rolez.lang.rolez.Type
import ch.trick17.rolez.lang.rolez.TypeParam
import ch.trick17.rolez.lang.rolez.TypeParamRef
import ch.trick17.rolez.lang.rolez.TypedBody
import ch.trick17.rolez.lang.rolez.UnaryMinus
import ch.trick17.rolez.lang.rolez.UnaryNot
import ch.trick17.rolez.lang.rolez.VarKind
import ch.trick17.rolez.lang.rolez.VarRef
import ch.trick17.rolez.lang.rolez.WhileLoop
import ch.trick17.rolez.lang.validation.AbstractRolezValidator
import it.xsemantics.runtime.RuleEnvironment
import java.util.Map
import java.util.Set

import static ch.trick17.rolez.lang.Constants.*
import static ch.trick17.rolez.lang.rolez.Role.*
import static ch.trick17.rolez.lang.rolez.RolezPackage.Literals.*

import static extension org.eclipse.emf.ecore.util.EcoreUtil.copy

system ch.trick17.rolez.lang.typesystem.RolezSystem

validatorExtends AbstractRolezValidator

inject extension RolezExtensions _
inject extension RolezUtils __

auxiliary {
    leastCommonSuperrole(Role r1, Role r2): Role
    strictSuperclasses(Class clazz): Set<Class> cached
    typeParamMap(Argumented a, RuleEnvironment G): Map<TypeParam, Type>
}

judgments {
    type      |- Expr e : output Type
    wellTyped |- Stmt s
    
    validArgs |- Argumented a << ParameterizedBody p
    
    subtypeExpr |- Expr left <| Type right
        error "Type mismatch: " + left.type.value?.string + " is not a subtype of " + right.string
        source left
        // TODO: left.type could need an environment. Convert to explicit
        // failure once issue code are supported:
        // https://github.com/LorenzoBettini/xsemantics/issues/58
    
    subtype  |- Type  left <: Type  right error "subtype" // Apparently, an error message is necessary for sensible error message selection
    subrole  |- Role  left <! Role  right error "subrole"
    subclass |- ClassRef left <~ ClassRef right error "subclass"
    
    equalType |- Type left ~~ Type right error "equal type"
    
    assignable |= Expr e
        error "Cannot assign to " + e.string source e
}

auxiliary leastCommonSuperrole(Role r1, Role r2) {
    if(r1.value > r2.value) r1 else r2 // Very simple so far
}

auxiliary strictSuperclasses(Class c) {
    val result = getAll(
        c,
        CLASS__SUPERCLASS,
        CLASS__SUPERCLASS,
        Class
    ).toSet
    
    val object = findClass(objectClassName, c)
    if(c != object && object != null)
        result.add(object)
    result
}

auxiliary typeParamMap(MemberAccess a, RuleEnvironment G) {
    G |- a.target : var RoleType targetType
    val base = targetType.base
    switch(base) {
        GenericClassRef: #{base.clazz.typeParam -> base.typeArg}
        default: emptyMap
    }
}

auxiliary typeParamMap(Argumented _, RuleEnvironment G) {
    emptyMap // TODO: Support for new, start and super(...)
}


rule TAssignment
    G |- Assignment a : Type t
from {
    G |- a.left : var Type leftType
    G |= a.left
    G |- a.right <| leftType
    t = leftType
}

rule TLogicalExpr
    G |- LogicalExpr e : newBooleanType
from {
    G |- e.left  <| newBooleanType
    G |- e.right <| newBooleanType
}

rule TEqualityExpr
    G |- EqualityExpr e : newBooleanType
from {
    G |- e.left  : var Type leftType
    G |- e.right : var Type rightType
    
    G |- leftType <: rightType
        or G |- rightType <: leftType
        or fail
            error "Cannot compare " + leftType.string + " to " + rightType.string
            source e
}

rule TRelationalExpr
    G |- RelationalExpr e : newBooleanType
from {
    G |- e.left  : var Type leftType
    G |- e.right : var Type rightType
    
    {
        G |- leftType  <: newIntType
        G |- rightType <: newIntType
    } or {
        G |- leftType  <: newCharType
        G |- rightType <: newCharType
    } or fail
        error "Cannot compare " + leftType.string + " to " + rightType.string
        source e
}

rule TArithmeticBinaryExpr
    G |- ArithmeticBinaryExpr e : Type t
from {
    G |- e.left  : var Type leftType
    G |- e.right : var Type rightType
    
    {
        e.op == OpArithmetic.PLUS;
        val stringType = newRoleType(READONLY, newClassRef(findClass(stringClassName, e)))
        
        G |- leftType <: stringType or G |- rightType <: stringType     
        t = stringType
    } or {
        G |- leftType  <: newIntType
        G |- rightType <: newIntType
        t = newIntType
    } or fail
        error "The operator + is undefined for the argument types "
            + leftType.string + ", " + rightType.string
        source e
}

rule TCast
    G |- Cast c : Type t
from {
    G |- c.expr : var Type exprType
    
    G |- exprType <: c.type // Upcasts are always fine
    or {
        // Downcasts only allowed if role stays the same and of there is a subclass relation
        c.type instanceof RoleType && exprType instanceof RoleType
        (exprType as RoleType).role == (c.type as RoleType).role
        G |- (c.type as RoleType).base <~ (exprType as RoleType).base
    } or fail
        error "Cannot cast " + exprType.string + " to " + c.type.string
        source c
    
    t = c.type
    // TODO: Allow coercion of primitive types?
}

rule TUnaryMinus
    G |- UnaryMinus m : newIntType
from {
    G |- m.expr <| newIntType
}

rule TUnaryNot
    G |- UnaryNot n : newBooleanType
from {
    G |- n.expr <| newBooleanType
}

rule TMemberAccess
    G |- MemberAccess a : Type t
from {
    G |- a.target : var Type targetType
    if(targetType instanceof RoleType) {
        if(a.isFieldAccess) {
            G |- targetType.role <! READONLY or fail
                error "Role mismatch: Cannot access field of a "
                    + targetType.role.string + " target"
                source a.target
            var fieldType = a.field.type
            switch(fieldType) {
                RoleType: {
                    val role = leastCommonSuperrole(targetType.role, fieldType.role)
                    t = newRoleType(role, fieldType.base.copy)
                }
                default: { t = fieldType }
            }
        }
        else { // method invoke
            // First, check if args are well-typed
            for(arg : a.args) {
                G |- arg : var Type _
            }
            G |- targetType.role <! a.method.thisRole or fail
                error "Role mismatch: Cannot call method " + a.method.string
                    +" on a " + targetType.role.string + " target"
                source a
            val returnType = a.method.type
            t = switch(returnType) {
                TypeParamRef: typeParamMap(a, G).get(returnType.param)
                default: returnType
            }
        }
    }
    else {
        fail
        error "Illegal target type for member access: " + targetType.string
        source a.target
    }
}

rule TThis
    G |- This t : Type type
    error "Cannot refer to \"this\" in this context" source t
from {
    type = env(G, "this", RoleType)
}

axiom TVarRef
    G |- VarRef r : r.variable.type

rule TNew
    G |- New n : newRoleType(READWRITE, n.classRef.copy)
from {
    for(arg : n.args) {
        G |- arg : var Type _
    }
}

axiom TThe
    G |- The t : newRoleType(READONLY, t.classRef.copy)

rule TStart
    G |- Start s : Type t
    error "rolez.lang.Task class is not defined" source s
from {
    val taskClass = findNormalClass(taskClassName, s)
    taskClass != null
    G |- s << s.taskRef.task
    t = newRoleType(PURE, newClassRef(taskClass, s.taskRef.task.type.copy))
}

rule TParenthesized
    G |- Parenthesized p : Type t
from {
    G |- p.expr : t
}

rule TStringLiteral
    G |- StringLiteral s : Type t
    error "rolez.lang.String class is not defined" source s
from {
    val stringClass = findClass(stringClassName, s)
    stringClass != null
    t = newRoleType(READWRITE, newClassRef(stringClass))
}

axiom TNullLiteral
    G |- NullLiteral __ : newNullType

axiom TIntLiteral
    G |- IntLiteral __ : newIntType

axiom TDoubleLiteral
    G |- DoubleLiteral __ : newDoubleType

axiom TBooleanLiteral
    G |- BooleanLiteral __ : newBooleanType

axiom TCharLiteral
    G |- CharLiteral __ : newCharType


rule WBlock
    G |- Block b
from {
    for(s : b.stmts) {
        G |- s
    }
}

rule WLocalVarDecl
    G |- LocalVarDecl d
from {
    d.initializer == null or G |- d.initializer <| d.variable.type
}

rule WIfStmt
    G |- IfStmt ifStmt
from {
    G |- ifStmt.^condition <| newBooleanType
    G |- ifStmt.thenPart
    G |- ifStmt.elsePart
}

rule WWhileLoop
    G |- WhileLoop l
from {
    G |- l.^condition <| newBooleanType
    G |- l.body
}

rule WSuperConstrCall
    G |- SuperConstrCall c
from {
    for(arg : c.args) {
        G |- arg : var Type _
    }
}

axiom WReturnNothing
    G |- ReturnNothing _

rule WReturnExpr
    G |- ReturnExpr r
from {
    // Apparently, this needs to be in braces:...
    {r.enclosingBody instanceof TypedBody} or fail
        error "Cannot return an expression in a constructor"
        source r
    
    G |- r.expr <| (r.enclosingBody as TypedBody).type
}

rule WExprStmt
    G |- ExprStmt s
from {
    G |- s.expr : var Type t
}


rule ValidArgs
    G |- Argumented a << ParameterizedBody p
from {
    a.args.size >= p.params.size
        or fail error "Too few arguments" source a
    a.args.size == p.params.size
        or fail error "Too many arguments" source a
    
    val paramTypes = p.params.map[
        val t = type
        switch(t) {
            TypeParamRef: typeParamMap(a, G).get(t.param)
            default: t
        }
    ]
    val i = a.args.iterator
    for(t : paramTypes) {
        G |- i.next <| t
    }
}


rule SubtypeExpr
    G |- Expr left <| Type right
from {
    G |- left : var Type leftType
    G |- leftType <: right
}


rule SubtypePrimitiveTypes
    G |- PrimitiveType left <: PrimitiveType right
from {
    left.class == right.class
}

rule SubtypeRoleTypes
    G |- RoleType left <: RoleType right
from {
    G |- left.role <! right.role // Subrole
    G |- left.base <~ right.base // Subclass
}

axiom SubtypeNull
    G |- Null __ <: ReferenceType ___

rule SubtypeTypeVarRef
    G |- TypeParamRef left <: TypeParamRef right
from {
    left.param == right.param
}

rule SubtypeGeneral
    G |- Type left <: Type right
from { fail }


rule Subrole
    G |- Role left <! Role right
from {
    left.value <= right.value
}


rule SubclassSimple
    G |- ClassRef left <~ SimpleClassRef right
from {
    left.clazz == right.clazz || strictSuperclasses(left.clazz).contains(right.clazz)
}

rule SubclassGeneric
    G |- GenericClassRef left <~ GenericClassRef right
from {
    left.clazz == right.clazz || strictSuperclasses(left.clazz).contains(right.clazz)
    G |- left.typeArg ~~ right.typeArg
}

rule SubclassGeneral
    G |- ClassRef left <~ ClassRef right
from { fail }

rule EqualTypePrimitiveTypes
    G |- PrimitiveType left ~~ PrimitiveType right
from {
    left.class == right.class
}

rule EqualTypeRoleTypes
    G |- RoleType left ~~ RoleType right
from {
    left.role == right.role
    left.base.clazz == right.base.clazz // Is this correct?
    left.base instanceof GenericClassRef == right.base instanceof GenericClassRef
    
    left.base instanceof SimpleClassRef
        or G |- (left.base as GenericClassRef).typeArg ~~ (right.base as GenericClassRef).typeArg
}

axiom EqualTypeNull
    G |- Null left ~~ Null right

rule EqualTypeTypeVarRef
    G |- TypeParamRef left ~~ TypeParamRef right
from {
    left.param == right.param
}

rule EqualTypeGeneral
    G |- Type left ~~ Type right
from { fail }


rule AVarRef
    G |= VarRef r
    error "Cannot assign to a value" source r
from {
    r.variable.kind == VarKind.VAR
}

rule AMemberAccess
    G |= MemberAccess a
from {
    a.isFieldAccess
    a.field.kind == VarKind.VAR
        or a.target instanceof This && a.enclosingBody instanceof Constr
        or fail error "Cannot assign to a value field" source a
    
    G |- a.target : var RoleType type
    G |- type.role <! READWRITE
        or fail error "Cannot assign to field of " + type.role + " object" source a
}

rule AExpr
    G |= Expr __
from { fail }


checkrule CheckStmt for
    Stmt s // Checked for all stmts individually, to get multiple error markers
from {
    val body = s.enclosingBody
    switch(body) {
        Method: {
            val thisType = newRoleType(body.thisRole, newClassRef(s.enclosingClass))
            "this" <- thisType |- s
        }
        Constr: {
            val thisType = newRoleType(READWRITE, newClassRef(s.enclosingClass))
            "this" <- thisType |- s
        }
        Task: {
            empty |- s
        }
    }
}