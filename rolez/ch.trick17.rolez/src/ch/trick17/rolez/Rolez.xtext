grammar ch.trick17.rolez.Rolez with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore"
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes

import "http://trick17.ch/rolez/Rolez"

Program:
    ('package' name=QualifiedName)?
    imports+=Import*
    classes+=Class+;

Import:
    'import' importedNamespace=QualifiedNameWithWildCard;

QualifiedName:
    ID ('.' ID)*;

QualifiedNameWithWildCard:
    QualifiedName '.*'?;

Class:
    NormalClass | SingletonClass;

NormalClass:
    (pure?='pure')? 'class' name=QualifiedName ('[' typeParam=TypeParam ']')? WithMappedClass WithSuperclass ('{'
        (constrs+=Constr | members+=Member)+
    '}')?;

// TODO: Understand mapped classes better. E.g., transitions do not work for guarded objects
// to which only mapped objects have a reference.

SingletonClass:
    'object' name=QualifiedName WithMappedClass WithSuperclass ('{'
        members+=Member+
    '}')?;

// FIXME: Singleton classes must not extend classes with no no-args constructor!
// TODO : Or even better, allow singleton classes to specify args to super constr: object Black extends Color(0, 0, 0)

TypeParam: name=ID;

Member:
    Field | Method;

Constr:
    {Constr} jvmConstr=[jvmTypes::JvmConstructor|Mapped]? 'new' WithParams WithBody?;

Field:
    jvmField=[jvmTypes::JvmField|Mapped]? kind=VarKind name=ID WithType ('=' initializer=Expr)?;

enum VarKind:
    VAL='val' | VAR='var';

Method:
    jvmMethod=[jvmTypes::JvmOperation|Mapped]?
    ('def' | declaredTask?='task' | superMethod=[Method|Override]) thisRole=Role name=MethodName
    ('[' roleParams+=RoleParam (',' roleParams+=RoleParam)* ']')?
    WithParams
    WithType
    WithBody?;

Mapped: 'mapped';

Override: 'override';

MethodName: ID | 'main';

RoleParam:
    name=ID ('includes' upperBound=BuiltInRole)?; // IMPROVE: Allow role parameter refs as upper bounds

Param:
    name=ID ':' type=Type;

Block:
    {Block} '{' (stmts+=Stmt)* '}';

Stmt:
    Block | LocalVarDecl | IfStmt | WhileLoop | ForLoop | SuperConstrCall | Return | ExprStmt;

LocalVarDecl:
    variable=LocalVar ('=' initializer=Expr)? ';';

LocalVar:
    kind=VarKind name=ID (WithType)?;

IfStmt:
    'if' '(' condition=Expr ')' thenPart=Stmt
    (=>'else' elsePart=Stmt)?;

WhileLoop:
    'while' '(' condition=Expr ')' body=Stmt;

ForLoop:
    'for' '(' initializer=LocalVarDecl condition=Expr ';' step=Expr ')' body=Stmt;

// IMPROVE: for-each and maybe parallel for-each

SuperConstrCall:
    {SuperConstrCall} constr=[Constr|Super] '(' args+=Expr (',' args+=Expr)* ')' ';';
    // Note that parentheses are required here. A "super" without parentheses is an expression.

Super: 'super';

Return:
    ReturnNothing | ReturnExpr;

ReturnNothing:
    {ReturnNothing} 'return' ';';

ReturnExpr:
    'return' expr=Expr ';';

ExprStmt:
    expr=Expr ';';

Expr:
    Assignment;

Assignment returns Expr:
    OrExpr ({Assignment.left=current} op=OpAssignment right=Expr)?;

enum OpAssignment:
    ASSIGN='=' | OR_ASSIGN='|=' | AND_ASSIGN='&='
    | PLUS_ASSIGN='+=' | MINUS_ASSIGN='-='
    | TIMES_ASSIGN='*=' | DIVIDED_BY_ASSIGN='/=' | MODULO_ASSIGN='%=';

OrExpr returns Expr:
    AndExpr ({LogicalExpr.left=current} op=OpOr right=AndExpr)*;

enum OpOr returns OpLogical: OR='||';

AndExpr returns Expr:
    EqualityExpr ({LogicalExpr.left=current} op=OpAnd right=EqualityExpr)*;

enum OpAnd returns OpLogical: AND='&&';

EqualityExpr returns Expr:
    RelationalExpr ({EqualityExpr.left=current} op=OpEquality right=RelationalExpr)?;

enum OpEquality: EQUALS='==' | NOT_EQUALS='!=';

RelationalExpr returns Expr:
    AdditiveExpr ({RelationalExpr.left=current} op=OpRelational right=AdditiveExpr)?;

enum OpRelational: SMALLER='<' | GREATER='>' | SMALLER_EQUALS='<=' | GREATER_EQUALS='>=';

AdditiveExpr returns Expr:
    MultiplicativeExpr ({ArithmeticBinaryExpr.left=current} op=OpAdditive right=MultiplicativeExpr)*;

enum OpAdditive returns OpArithmetic: PLUS='+' | MINUS='-';

MultiplicativeExpr returns Expr:
    Cast ({ArithmeticBinaryExpr.left=current} op=OpMultiplicative right=Cast)*;

enum OpMultiplicative returns OpArithmetic: TIMES='*' | DIVIDED_BY='/' | MODULO='%';

Cast returns Expr:
    UnaryMinus ({Cast.expr=current} 'as' type=Type)*;

UnaryMinus returns Expr:
    UnaryNot | {UnaryMinus} '-' expr=UnaryNot;

UnaryNot returns Expr:
    Start | {UnaryNot} '!' expr=MemberAccess;

/* Start and MemberAccess rules have different syntax, but both create a MemberAccess object */

Start returns Expr:
    MemberAccess (
        {MemberAccess.target=current}
        taskStart?='start' member=[Method|MethodName]
        ('[' roleArgs+=Role (',' roleArgs+=Role)* ']')?
        ('(' args+=Expr (',' args+=Expr)* ')')?
    )*;
    // IMPROVE: Allow starting tasks without "this"

MemberAccess returns Expr:
    SimpleExpr (
        {MemberAccess.target=current}
        '.' member=[Member|MethodName]
        ('[' roleArgs+=Role (',' roleArgs+=Role)* ']')?
        ('('     args+=Expr (','     args+=Expr)* ')')?
    )*;
    // IMPROVE: Allow member accesses without "this"

SimpleExpr returns Expr:
    {This} 'this' | {Super} 'super' | VarRef | New | The | Parenthesized | Literal;

VarRef:
    variable=[Var];

New:
    constr=[Constr|NewKeyword] classRef=NewClassRef WithArgs;

NewKeyword: 'new';

The:
    'the' classRef=TheClassRef;

Parenthesized: '(' expr=Expr ')';

Literal:
    IntLiteral | DoubleLiteral | BooleanLiteral | CharLiteral | StringLiteral | {NullLiteral} 'null';

StringLiteral: value=STRING;

terminal STRING: '"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|'"') )* '"';

IntLiteral: value=INT;

DoubleLiteral: value=DOUBLE;

terminal DOUBLE: INT '.' INT;

BooleanLiteral: value=Bool;

CharLiteral: value=CHAR;

terminal CHAR returns EChar: "'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|"'") ) "'";

Bool returns EBoolean: 'true' | 'false';


Type:
    ReferenceType | PrimitiveType | TypeParamRef;

ReferenceType:
    RoleType | {Null} NULL_TYPE;

PrimitiveType:
    NumericType | {Boolean} 'boolean' | {Void} 'void'?;

NumericType:
    {Int} 'int' | {Double} 'double' | {Char} 'char';

TypeParamRef:
    param=[TypeParam] ('with' restrictingRole=Role)?;

RoleType:
    role=Role base=ClassRef;

terminal NULL_TYPE: 'Null';

Role:
    RoleParamRef | BuiltInRole;

RoleParamRef:
    param=[RoleParam];

BuiltInRole:
    {Pure} 'pure' | {ReadOnly} 'readonly' | {ReadWrite} 'readwrite';
    // TODO: Use shorter names like pure, read, and write?

ClassRef:
    SimpleClassRef | GenericClassRef;

SimpleClassRef:
    clazz=[Class|QualifiedName];

GenericClassRef:
    clazz=[NormalClass|QualifiedName] '[' typeArg=Type ']';

NewClassRef returns ClassRef:
    {SimpleClassRef} (clazz=[NormalClass] | '(' clazz=[NormalClass|QualifiedName] ')')
    | {GenericClassRef} (clazz=[NormalClass] | '(' clazz=[NormalClass|QualifiedName] ')') '[' typeArg=Type ']';

TheClassRef returns ClassRef:
    {SimpleClassRef} clazz=[SingletonClass]
    | {SimpleClassRef} '(' clazz=[SingletonClass|QualifiedName] ')';

/* Fragments */

fragment WithMappedClass returns Class:
    ('mapped' 'to' jvmClass=[jvmTypes::JvmGenericType|QualifiedName])?;

fragment WithSuperclass returns Class: ('extends' superclassRef=ClassRef)?;

fragment WithType returns Typed: ':' type=Type;

fragment WithParams returns Executable: ('(' params+=Param (',' params+=Param)* ')')?;

fragment WithBody returns Executable: body=Block;

fragment WithArgs returns Argumented: ('(' args+=Expr (',' args+=Expr)* ')')?;