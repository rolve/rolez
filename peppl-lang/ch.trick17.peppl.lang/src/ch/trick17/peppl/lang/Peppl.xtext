grammar ch.trick17.peppl.lang.Peppl with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore"

generate peppl "http://trick17.ch/peppl/lang/Peppl"

Program:
    classes+=Class* 'main' mainBlock=Block & classes+=Class*;

Class:
    'class' name=ID ('{' members+=Member+ '}')?;

Member:
    Field | Method;

Field:
    kind=VarKind name=ID ':' type=Type;

enum VarKind:
    VAL='val' | VAR='var';

Method:
    'def' name=ID
    ('(' params+=Parameter (',' params+=Parameter)* ')')?
    ':' returnType=Type
    body=Block;

Parameter:
    name=ID ':' type=Type;

Block:
    {Block} '{' (statements+=Statement)* '}';

Statement:
    Block | LocalVariable | IfElse | WhileLoop | ForLoop | Return | ExpressionStatement;

LocalVariable:
    kind=VarKind name=ID ':' type=Type ('=' initializer=Expression)? ';';

IfElse:
    'if' '(' condition=Expression ')' then=Statement
    (=>'else' else=Statement)?;

WhileLoop:
    'while' '(' condition=Expression ')' body=Statement;

ForLoop:
    'for' '(' loopVar=LoopVariable ')' body=Statement;

LoopVariable returns LocalVariable:
    {LoopVariable} name=ID ':' type=Type '<-' range=Expression;

Return:
    'return' expr=Expression ';';

ExpressionStatement:
    expr=Expression ';';

Expression:
    OrExpression ({Assignment.left=current} '=' right=Expression)?;

OrExpression returns Expression:
    AndExpression ({BooleanExpression.left=current} op=OpOr right=AndExpression)?;

enum OpOr returns OpBoolean: OR='||';

AndExpression returns Expression:
    EqualityExpression ({BooleanExpression.left=current} op=OpAnd right=EqualityExpression)?;

enum OpAnd returns OpBoolean: AND='&&';

EqualityExpression returns Expression:
    RelationalExpression ({EqualExpression.left=current} op=OpEquality right=RelationalExpression)?;

enum OpEquality: EQUALS='==' | NOT_EQUALS='!=';

RelationalExpression returns Expression:
    AdditiveExpression ({RelationalExpression.left=current} op=OpRelational right=AdditiveExpression)?;

enum OpRelational: SMALLER='<' | GREATER='>' | SMALLER_EQUALS='<=' | GREATER_EQUALS='>=';

AdditiveExpression returns Expression:
    MultiplicativeExpression ({ArithmeticExpression.left=current} op=OpAdditive right=MultiplicativeExpression)?;

enum OpAdditive returns OpArithmetic: PLUS='+' | MINUS='-';

MultiplicativeExpression returns Expression:
    UnaryExpression ({ArithmeticExpression.left=current} op=OpMultiplicative right=UnaryExpression)?;

enum OpMultiplicative returns OpArithmetic: TIMES='*' | DIVIDED_BY='/' | MODULO='%';

UnaryExpression returns Expression:
    MemberAccess | {UnaryExpression} op=OpUnary right=MemberAccess;

enum OpUnary: MINUS='-' | NOT='!';

MemberAccess returns Expression:
    SimpleExpression
    (
        {FieldAccess.target=current} '.' member+=[Member]
        | {MethodInvoke.target=current} '.' member+=[Member] '(' (args+=Expression (',' args+=Expression)*)? ')'
    )*;

SimpleExpression returns Expression:
    {This} 'this' | VariableRef | New | Literal | Parenthesized;

VariableRef: var=[Variable];

Variable: LocalVariable | Parameter;

New:
    'new' class=[Class]
    ('(' arguments+=Expression (',' arguments+=Expression)* ')')?;

Literal:
    StringLiteral | IntLiteral | BooleanLiteral | {NullLiteral} 'null';

StringLiteral: value=STRING;

IntLiteral: value=INT;

BooleanLiteral: value=Bool;

Bool returns EBoolean: 'true' | 'false';

Parenthesized: '(' expr=Expression ')';

Type:
    (role=Role)? base=[Class] | PrimitiveType | {String} STRING_TYPE;

terminal STRING_TYPE: 'String';

PrimitiveType:
    {Int} 'int' | {Boolean} 'boolean' | {Char} 'char' | {Void} 'void';

enum Role:
    READWRITE='readwrite' | READONLY='readonly' | INACCESSIBLE='inaccessible';