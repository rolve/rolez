grammar ch.trick17.peppl.lang.Peppl with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore"

generate peppl "http://trick17.ch/peppl/lang/Peppl"

Program:
    elements+=TopLevelElement+;

TopLevelElement:
    Class | Main;

Class:
    'class' name=ID ('extends' superclass=[Class])?
    ('{'
        (constructors+=Constructor | members+=Member)+
    '}')?;

Main:
    'main' body=Block;

Member:
    Field | Method;

Constructor:
    'new' ('(' params+=Parameter (',' params+=Parameter)* ')')? body=Block;

Field:
    kind=VarKind name=ID ':' type=Type;

enum VarKind:
    VAL='val' | VAR='var';

Method:
    (overriding?='override' | 'def')
    thisRole=Role name=ID
    ('(' params+=Parameter (',' params+=Parameter)* ')')?
    ':' type=Type
    body=Block;

Parameter:
    kind=Val name=ID ':' type=Type;

enum Val returns VarKind: VAL='val';

Block:
    {Block} '{' (statements+=Statement)* '}';

Statement:
    Block | LocalVariableDecl | IfElse | WhileLoop | Return | ExpressionStatement;

LocalVariableDecl:
    variable=LocalVariable ('=' initializer=Expression)? ';';

LocalVariable:
    kind=VarKind name=ID ':' type=Type;

IfElse:
    'if' '(' condition=Expression ')' thenPart=Statement
    (=>'else' elsePart=Statement)?;

WhileLoop:
    'while' '(' condition=Expression ')' body=Statement;

Return:
    'return' expr=Expression ';';

ExpressionStatement:
    expr=Expression ';';

Expression:
    Assignment;

Assignment returns Expression:
    OrExpression ({Assignment.left=current} '=' right=Expression)?;

OrExpression returns Expression:
    AndExpression ({BooleanExpression.left=current} op=OpOr right=AndExpression)?;

enum OpOr returns OpBoolean: OR='||';

AndExpression returns Expression:
    EqualityExpression ({BooleanExpression.left=current} op=OpAnd right=EqualityExpression)?;

enum OpAnd returns OpBoolean: AND='&&';

EqualityExpression returns Expression:
    RelationalExpression ({EqualityExpression.left=current} op=OpEquality right=RelationalExpression)?;

enum OpEquality: EQUALS='==' | NOT_EQUALS='!=';

RelationalExpression returns Expression:
    AdditiveExpression ({RelationalExpression.left=current} op=OpRelational right=AdditiveExpression)?;

enum OpRelational: SMALLER='<' | GREATER='>' | SMALLER_EQUALS='<=' | GREATER_EQUALS='>=';

AdditiveExpression returns Expression:
    MultiplicativeExpression ({ArithmeticExpression.left=current} op=OpAdditive right=MultiplicativeExpression)*;

enum OpAdditive returns OpArithmetic: PLUS='+' | MINUS='-';

MultiplicativeExpression returns Expression:
    Cast ({ArithmeticExpression.left=current} op=OpMultiplicative right=Cast)*;

enum OpMultiplicative returns OpArithmetic: TIMES='*' | DIVIDED_BY='/' | MODULO='%';

Cast returns Expression:
    UnaryMinus | {Cast} '(' type=Type ')' expr=Cast;

UnaryMinus returns Expression:
    UnaryNot | {UnaryMinus} '-' expr=MemberAccess;

UnaryNot returns Expression:
    MemberAccess | {UnaryNot} '!' expr=MemberAccess;

MemberAccess returns Expression:
    SimpleExpression
    (
        '.' {MemberAccess.target=current} selector=Selector
    )*;

Selector: FieldSelector | MethodSelector;

FieldSelector: field=[Field];

MethodSelector: method=[Method] '(' (args+=Expression (',' args+=Expression)*)? ')';

SimpleExpression returns Expression:
    {This} 'this' | VariableRef | New | Parenthesized | Literal;

VariableRef: variable=[Variable];

New:
    'new' clazz=[Class]
    ('(' args+=Expression (',' args+=Expression)* ')')?;

Parenthesized: '(' expr=Expression ')';

Literal:
    StringLiteral | {NullLiteral} 'null' | IntLiteral | BooleanLiteral | CharLiteral;

StringLiteral: value=STRING;

terminal STRING: '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"';

IntLiteral: value=INT;

BooleanLiteral: value=Bool;

CharLiteral: value=CHAR;

terminal CHAR returns EChar: "'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") ) "'";

Bool returns EBoolean: 'true' | 'false';


Type:
    ReferenceType | PrimitiveType;

ReferenceType:
    RoleType | {Null} NULL_TYPE;

PrimitiveType:
    {Int} 'int' | {Boolean} 'boolean' | {Char} 'char' | {Void} 'void';

RoleType:
    role=Role base=[Class];

terminal NULL_TYPE: 'Null';

enum Role:
    READWRITE='readwrite' | READONLY='readonly' | INACCESSIBLE='inaccessible';

Variable:
    LocalVariable | => Parameter; // => only needed to avoid warnings. Rule is not used anyway.

Named:
    Class | Typed;

Typed:
    Member | => Variable; // => only needed to avoid warnings. Rule is not used anyway.

WithBlock:
    Main | WithParameters;

WithParameters:
    Constructor | Method;

WithArguments:
    New | MethodSelector;