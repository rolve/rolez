grammar ch.trick17.peppl.lang.Peppl with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore"

generate peppl "http://trick17.ch/peppl/lang/Peppl"

Program:
    ('package' name=QualifiedName)?
    imports+=Import*
    elements+=ClassLike+;

Import:
    'import' importedNamespace=QualifiedNameWithWildCard;

QualifiedName:
    ID ('.' ID)*;

QualifiedNameWithWildCard:
    QualifiedName '.*'?;

ClassLike:
    Class | Task;

Class:
    'class' name=ID ('extends' superclass=[Class])?
    ('{'
        (constructors+=Constructor | members+=Member)+
    '}')?;

Task:
    'task' name=ID ('(' params+=Param (',' params+=Param)* ')')?
    ':' type=Type body=Block;

Member:
    Field | Method;

Constructor:
    'new' ('(' params+=Param (',' params+=Param)* ')')? body=Block;

Field:
    kind=VarKind name=ID ':' type=Type;

enum VarKind:
    VAL='val' | VAR='var';

Method:
    (overriding?='override' | 'def')
    thisRole=Role name=ID
    ('(' params+=Param (',' params+=Param)* ')')?
    ':' type=Type body=Block;

Param:
    kind=Val name=ID ':' type=Type;

enum Val returns VarKind: VAL='val';

Block:
    {Block} '{' (stmts+=Stmt)* '}';

Stmt:
    Block | LocalVarDecl | IfStmt | WhileLoop | Return | ExprStmt;

LocalVarDecl:
    variable=LocalVar ('=' initializer=Expr)? ';';

LocalVar:
    kind=VarKind name=ID ':' type=Type;

IfStmt:
    'if' '(' condition=Expr ')' thenPart=Stmt
    (=>'else' elsePart=Stmt)?;

WhileLoop:
    'while' '(' condition=Expr ')' body=Stmt;

Return:
    ReturnNothing | ReturnExpr;

ReturnNothing:
    {ReturnNothing} 'return;';

ReturnExpr:
    'return' expr=Expr ';';

ExprStmt:
    expr=Expr ';';

Expr:
    Assignment;

Assignment returns Expr:
    OrExpr ({Assignment.left=current} '=' right=Expr)?;

OrExpr returns Expr:
    AndExpr ({BooleanExpr.left=current} op=OpOr right=AndExpr)?;

enum OpOr returns OpBoolean: OR='||';

AndExpr returns Expr:
    EqualityExpr ({BooleanExpr.left=current} op=OpAnd right=EqualityExpr)?;

enum OpAnd returns OpBoolean: AND='&&';

EqualityExpr returns Expr:
    RelationalExpr ({EqualityExpr.left=current} op=OpEquality right=RelationalExpr)?;

enum OpEquality: EQUALS='==' | NOT_EQUALS='!=';

RelationalExpr returns Expr:
    AdditiveExpr ({RelationalExpr.left=current} op=OpRelational right=AdditiveExpr)?;

enum OpRelational: SMALLER='<' | GREATER='>' | SMALLER_EQUALS='<=' | GREATER_EQUALS='>=';

AdditiveExpr returns Expr:
    MultiplicativeExpr ({ArithmeticExpr.left=current} op=OpAdditive right=MultiplicativeExpr)*;

enum OpAdditive returns OpArithmetic: PLUS='+' | MINUS='-';

MultiplicativeExpr returns Expr:
    Cast ({ArithmeticExpr.left=current} op=OpMultiplicative right=Cast)*;

enum OpMultiplicative returns OpArithmetic: TIMES='*' | DIVIDED_BY='/' | MODULO='%';

Cast returns Expr:
    UnaryMinus ({Cast.expr=current} 'as' type=Type)*;

UnaryMinus returns Expr:
    UnaryNot | {UnaryMinus} '-' expr=UnaryNot;

UnaryNot returns Expr:
    MemberAccess | {UnaryNot} '!' expr=MemberAccess;

MemberAccess returns Expr:
    SimpleExpr ({MemberAccess.target=current} '.' selector=Selector)*;

Selector: FieldSelector | MethodSelector;

FieldSelector: field=[Field];

MethodSelector: method=[Method] '(' (args+=Expr (',' args+=Expr)*)? ')';
// TODO: Allow method calls without parentheses

SimpleExpr returns Expr:
    {This} 'this' | VarRef | New | Start | Parenthesized | Literal;

VarRef: variable=[Var];

New:
    'new' classRef=ClassRef
    ('(' args+=Expr (',' args+=Expr)* ')')?;

Start:
    'start' taskRef=TaskRef
    ('(' args+=Expr (',' args+=Expr)* ')')?;

Parenthesized: '(' expr=Expr ')';

Literal:
    StringLiteral | {NullLiteral} 'null' | IntLiteral | DoubleLiteral | BooleanLiteral | CharLiteral | UnitLiteral;

StringLiteral: value=STRING;

terminal STRING: '"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|'"') )* '"';

IntLiteral: value=INT;

DoubleLiteral: value=DOUBLE;

terminal DOUBLE: INT '.' INT;

BooleanLiteral: value=Bool;

CharLiteral: value=CHAR;

UnitLiteral: {UnitLiteral} 'unit';

terminal CHAR returns EChar: "'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|"'") ) "'";

Bool returns EBoolean: 'true' | 'false';


Type:
    ReferenceType | PrimitiveType;

ReferenceType:
    RoleType | {Null} NULL_TYPE;

PrimitiveType:
    {Int} 'int' | {Double} 'double' | {Boolean} 'boolean' | {Char} 'char' | {Unit} 'unit'?;

RoleType:
    role=Role base=ClassRef;

terminal NULL_TYPE: 'Null';

enum Role:
    READWRITE='readwrite' | READONLY='readonly' | PURE='pure';

ClassRef:
    SimpleClassRef | GenericClassRef;

SimpleClassRef:
    clazz=[Class] | '(' clazz=[Class|QualifiedName] ')';
    // To avoid ambiguity with field reads, qualified names must be in parentheses

GenericClassRef:
    clazz=[Class|QualifiedName] '[' typeArg=Type ']';

TaskRef:
    (task=[Task] | '(' task=[Task|QualifiedName] ')');

Var:
    LocalVar | => Param; // => only needed to avoid warnings. Rule is not used anyway.

Named:
    ClassLike | Typed;

Typed:
    Member | Task | => Var; // => only needed to avoid warnings. Rule is not used anyway.

ParameterizedBody:
    Constructor | Method | Task;

Argumented:
    MethodSelector | New | Start;