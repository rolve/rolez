/*
 * generated by Xtext
 */
package ch.trick17.peppl.lang.validation

import ch.trick17.peppl.lang.peppl.Block
import ch.trick17.peppl.lang.peppl.Class
import ch.trick17.peppl.lang.peppl.Field
import ch.trick17.peppl.lang.peppl.GenericClassRef
import ch.trick17.peppl.lang.peppl.IfStmt
import ch.trick17.peppl.lang.peppl.Method
import ch.trick17.peppl.lang.peppl.PepplPackage.Literals
import ch.trick17.peppl.lang.peppl.Program
import ch.trick17.peppl.lang.peppl.ReturnExpr
import ch.trick17.peppl.lang.peppl.SimpleClassRef
import ch.trick17.peppl.lang.peppl.Stmt
import ch.trick17.peppl.lang.peppl.Var
import ch.trick17.peppl.lang.peppl.Void
import ch.trick17.peppl.lang.typesystem.PepplSystem
import ch.trick17.peppl.lang.typesystem.PepplUtils
import ch.trick17.peppl.lang.typesystem.validation.PepplSystemValidator
import java.util.HashSet
import java.util.Set
import javax.inject.Inject
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.mwe2.language.scoping.QualifiedNameProvider
import org.eclipse.xtext.validation.Check
import ch.trick17.peppl.lang.peppl.PepplPackage

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class PepplValidator extends PepplSystemValidator {

    public static val INVALID_NAME = "invalid name"
    public static val OBJECT_CLASS_NOT_DEFINED = "object class not defined"
    public static val DUPLICATE_CLASS = "duplicate class"
    public static val DUPLICATE_METHOD = "duplicate method"
    public static val DUPLICATE_FIELD = "duplicate field"
    public static val DUPLICATE_VARIABLE = "duplicate variable"
    public static val MISSING_OVERRIDE = "missing override"
    public static val INCORRECT_OVERRIDE = "incorrect override"
    public static val INCOMPATIBLE_RETURN_TYPE = "incompatible return type"
    public static val INCOMPATIBLE_THIS_ROLE = "incompatible \"this\" role"
    public static val INCORRECT_RETURN = "incorrect return statement"
    public static val MISSING_RETURN = "missing return statement"
    public static val AMBIGUOUS_CALL = "ambiguous call"
    public static val MISSING_TYPE_ARGS = "missing type arguments"
    public static val INCORRECT_TYPE_ARGS = "incorrect type arguments"
    public static val INCORRECT_OBJECT_SUPERCLASS = "incorrect object superclass"
    public static val INCORRECT_ARRAY_SUPERCLASS = "incorrect array superclass"
    public static val CIRCULAR_INHERITANCE = "circular inheritance"

    @Inject private extension PepplSystem
    @Inject private extension PepplUtils
    @Inject private extension QualifiedNameProvider
    
	@Check
    def checkClassNameStartsWithCapital(Class c) {
        if(!Character.isUpperCase(c.name.charAt(0)))
            warning("Name should start with a capital",
                Literals.NAMED__NAME, INVALID_NAME)
    }
	
	@Check
	def checkObjectExists(Class c) {
	    if(c.superclass == null && findClass(objectClassName, c) == null)
	       error("Object class is not defined",
	           Literals.NAMED__NAME,  OBJECT_CLASS_NOT_DEFINED)
	}
	
	@Check
	def checkNoDuplicateClasses(Class c) {
	    val matching = c.enclosingProgram.classes.filter[name.equals(c.name)]
        if(matching.size < 1)
           throw new AssertionError
        if(matching.size > 1)
           error("Duplicate class " + c.name, Literals.NAMED__NAME, DUPLICATE_CLASS)
	}
	
    @Check
    def checkObjectClass(Class c) {
        if(c.fullyQualifiedName == objectClassName) {
            if(c.superclass != null)
               error(c.fullyQualifiedName + " must not have a superclass",
                   c, Literals.CLASS__SUPERCLASS, INCORRECT_OBJECT_SUPERCLASS)
        }
    }
    
    @Check
    def checkArrayClass(Class c) {
        if(c.fullyQualifiedName == arrayClassName) {
            if(c.actualSuperclass != findClass(objectClassName, c))
               error("The superclass of " + c.fullyQualifiedName + " must be "+ objectClassName,
                   c, Literals.CLASS__SUPERCLASS, INCORRECT_ARRAY_SUPERCLASS)
        }
    }
    
    // TODO: Check string class
    
    @Check
    def checkCircularInheritance(Class c) {
        if(c.findSuperclass(c))
            error("Circular inheritance", c, Literals.CLASS__SUPERCLASS, CIRCULAR_INHERITANCE)
    }
    
    private def boolean findSuperclass(Class c, Class toFind) {
        switch(c.actualSuperclass) {
            case null: false
            case toFind: true
            default:
                findSuperclass(c.actualSuperclass, toFind)
        }
    }
	
	/**
	 * Checks that there are no other methods in the same class with the same
	 * signature. The signature does not comprise the role of <code>this</code>,
	 * therefore <code>this</code>-role-based overloading is not possible.
	 * <p>
	 * The reason for this is that it might be surprising to programmers if
	 * methods are virtually dispatched based on the class of the target, but
	 * statically dispatched based on its role.
	 */
    @Check
    def checkNoDuplicateMethods(Method m) {
        val matching = m.enclosingClass.methods.filter[equalSignature(it, m)]
        if(matching.size < 1)
           throw new AssertionError
        if(matching.size > 1)
           error("Duplicate method " + m.name + "("+ m.params.join(",") + ")",
               Literals.NAMED__NAME, DUPLICATE_METHOD)
    }
    
    @Check
    def checkNoDuplicateFields(Field f) {
        val matching = f.enclosingClass.fields.filter[name.equals(f.name)]
        if(matching.size < 1)
           throw new AssertionError
        if(matching.size > 1)
           error("Duplicate field " + f.name, Literals.NAMED__NAME, DUPLICATE_FIELD)
    }
    
    @Check
    def checkNoDuplicateVars(Var v) {
        val matching = v.enclosingElemWithBody.variables.filter[name.equals(v.name)]
        if(matching.size < 1)
           throw new AssertionError
        if(matching.size > 1)
           error("Duplicate variable " + v.name, Literals.NAMED__NAME, DUPLICATE_VARIABLE)
    }
	
	/**
	 * Checks that overriding methods actually override a method in a super
	 * class and that the return type is co- and the <code>this</code> role is
	 * contravariant. Note that covariance for the <code>this</code> role would
	 * be unsafe.
	 */
	@Check
	def checkOverrides(Method m) {
	    val superMethods = m.enclosingClass.actualSuperclass
	           .allMembers.filter(Method)
        val matching = superMethods.filter[equalSignature(it, m)]
	    
	    if(matching.size > 0) {
	        if(m.overriding) {
                for(match : matching) {
                    if(subtype(envFor(m), m.type, match.type).failed)
                        error("The return type is incompatible with overridden method" + match,
                            Literals.TYPED__TYPE, INCOMPATIBLE_RETURN_TYPE)
                    if(subrole(match.thisRole, m.thisRole).failed)
                        error("This role of \"this\" is incompatible with overridden method" + match,
                            Literals.TYPED__TYPE, INCOMPATIBLE_THIS_ROLE)
                }
            }
            else
                error("Method must be declared with \"override\" since it
                        actually overrides a superclass method",
                    Literals.NAMED__NAME, MISSING_OVERRIDE)
        }
        else if(m.overriding)
           error("Method must override a superclass method",
               Literals.NAMED__NAME, INCORRECT_OVERRIDE)
	}
	
	@Check
	def checkReturn(Method m) {
	    if(!(m.type instanceof Void)) {
	        checkReturnExpr(m.body)
	    }
	}
	
	/**
	 * Checks if the given statement is guaranteed to return an expression,
	 * reports an error otherwise.
	 */
	private def void checkReturnExpr(Stmt s) {
	    switch (s) {
            ReturnExpr: { /* Found it! */ }
            Block: {
                if(s.stmts.empty)
                    error("Method must return a value of type " + s.enclosingMethod.type.stringRep,
                        s, null, MISSING_RETURN)
                else
                    checkReturnExpr(s.stmts.last)
            }
            IfStmt: {
                checkReturnExpr(s.thenPart)
                if(s.elsePart == null)
                    error("Method must return a value of type " + s.enclosingMethod.type.stringRep,
                        s, null, MISSING_RETURN)
                else
                    checkReturnExpr(s.elsePart)
            }
            default:
                if(s != null)
                    error("Method must return a value of type " + s.enclosingMethod.type.stringRep,
                        s, null, MISSING_RETURN)
        }
        // IMPROVE: Better handling of dead code
    }
    
    @Check
    def checkSimpleClassRef(SimpleClassRef ref) {
        if(ref.clazz == findClass(arrayClassName, ref))
            error("Class " + ref.clazz.name + " takes type arguments",
                ref, Literals.CLASS_REF__CLAZZ, MISSING_TYPE_ARGS)
    }
    
    @Check
    def checkGenericClassRef(GenericClassRef ref) {
        if(ref.clazz != findClass(arrayClassName, ref))
            error("Class " + ref.clazz.name + " does not take type arguments",
                ref, Literals.GENERIC_CLASS_REF__TYPE_ARG, INCORRECT_TYPE_ARGS)
    }
    
	/*
	 * Delayed errors
	 */
	
	private val Set<Error> delayedErrors = new HashSet
	
	/**
	 * Can be called by other classes (e.g. the scope provider) to create
	 * errors before the actual validation phase. The validator will later
	 * report these errors.
	 */
    def delayedError(String message, EObject source, EStructuralFeature feature, String code, String... issueData) {
        delayedErrors.add(new Error(message, source, feature, code, issueData))
    }
    
    private static class Error {
        val String message
        val EObject source
        val EStructuralFeature feature
        val String code
        val String[] issueData
        
        new(String message, EObject source, EStructuralFeature feature, String code, String... issueData) {
            this.message = message
            this.source = source
            this.feature = feature
            this.code = code
            this.issueData = issueData
        }
    }
    
    @Check
    def reportDelayedErrors(Program p) {
        delayedErrors.filter[source.enclosingProgram == p].forEach[
            error(message, source, feature, code, issueData)
        ]
    }
}