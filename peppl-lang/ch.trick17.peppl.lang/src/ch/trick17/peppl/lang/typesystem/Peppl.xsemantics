import ch.trick17.peppl.lang.peppl.ArithmeticExpression
import ch.trick17.peppl.lang.peppl.Assignment
import ch.trick17.peppl.lang.peppl.Block
import ch.trick17.peppl.lang.peppl.BooleanExpression
import ch.trick17.peppl.lang.peppl.BooleanLiteral
import ch.trick17.peppl.lang.peppl.CharLiteral
import ch.trick17.peppl.lang.peppl.Class
import ch.trick17.peppl.lang.peppl.EqualityExpression
import ch.trick17.peppl.lang.peppl.Expression
import ch.trick17.peppl.lang.peppl.ExpressionStatement
import ch.trick17.peppl.lang.peppl.FieldSelector
import ch.trick17.peppl.lang.peppl.IfElse
import ch.trick17.peppl.lang.peppl.IntLiteral
import ch.trick17.peppl.lang.peppl.LocalVariable
import ch.trick17.peppl.lang.peppl.MemberAccess
import ch.trick17.peppl.lang.peppl.Method
import ch.trick17.peppl.lang.peppl.MethodSelector
import ch.trick17.peppl.lang.peppl.New
import ch.trick17.peppl.lang.peppl.Null
import ch.trick17.peppl.lang.peppl.NullLiteral
import ch.trick17.peppl.lang.peppl.OpArithmetic
import ch.trick17.peppl.lang.peppl.Parenthesized
import ch.trick17.peppl.lang.peppl.PepplPackage
import ch.trick17.peppl.lang.peppl.PrimitiveType
import ch.trick17.peppl.lang.peppl.Program
import ch.trick17.peppl.lang.peppl.ReferenceType
import ch.trick17.peppl.lang.peppl.RelationalExpression
import ch.trick17.peppl.lang.peppl.Return
import ch.trick17.peppl.lang.peppl.Role
import ch.trick17.peppl.lang.peppl.RoleType
import ch.trick17.peppl.lang.peppl.Statement
import ch.trick17.peppl.lang.peppl.StringLiteral
import ch.trick17.peppl.lang.peppl.This
import ch.trick17.peppl.lang.peppl.Type
import ch.trick17.peppl.lang.peppl.UnaryMinus
import ch.trick17.peppl.lang.peppl.UnaryNot
import ch.trick17.peppl.lang.peppl.VariableRef
import ch.trick17.peppl.lang.peppl.WhileLoop
import ch.trick17.peppl.lang.validation.AbstractPepplValidator
import java.util.List
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.scoping.IGlobalScopeProvider
import org.eclipse.xtext.scoping.IScopeProvider

import static ch.trick17.peppl.lang.peppl.Role.*
import static ch.trick17.peppl.lang.peppl.VarKind.*
import org.eclipse.emf.common.util.EList

system ch.trick17.peppl.lang.typesystem.PepplSystem

validatorExtends AbstractPepplValidator

inject extension PepplTypeUtils __
inject IScopeProvider scopeProv
inject IGlobalScopeProvider globalScopeProv

auxiliary {
    leastCommonSuperrole(Role r1, Role r2): Role
    actualSuperclass(Class clazz): Class cached
    strictSuperclasses(Class clazz): Set<Class> cached
    enclosingMethod(EObject object): Method
    enclosingClass(EObject object): Class
    enclosingProgram(EObject object): Program
    findClass(QualifiedName name, EObject context): Class
}

judgments {
    type      |- Expression expr : output Type
    wellTyped |- Statement s
    
    subtypeSequence   |- List<Expression> expressions << List<Type> types ~~ EObject src
    subtypeExpression |- Expression left              <| Type right
        error "Type mismatch: " + left.type.value.stringRep + " is not a subtype of " + right.stringRep
        source left
    
    subtype  |- Type  left <: Type  right error "subtype" // Apparently, when no error message is specified, some "source" is taken, which can be very wrong...
    subrole  |- Role  left <! Role  right error "subrole"
    subclass |- Class left <~ Class right error "subclass"
    
    assignable |= Expression expr
        error "Cannot assign to " + expr.stringRep
        source expr
}

auxiliary leastCommonSuperrole(Role r1, Role r2) {
    if(r1.value > r2.value) r1 else r2 // Very simple so far
}

auxiliary actualSuperclass(Class clazz) {
    val objectClass = findClass(objectClassName, clazz)
    if(clazz == objectClass)
        null
    else if(clazz.superclass == null)
        objectClass
    else
        clazz.superclass
}

auxiliary strictSuperclasses(Class clazz) {
    val result = getAll(
        clazz,
        PepplPackage.eINSTANCE.class_Superclass,
        PepplPackage.eINSTANCE.class_Superclass,
        Class
    ).toSet
    
    val object = findClass(objectClassName, clazz)
    if(clazz != object && object != null)
        result.add(object)
    result
}

auxiliary enclosingMethod(Method method) {
    method
}

auxiliary enclosingMethod(EObject object) {
    object?.eContainer?.enclosingMethod
}

auxiliary enclosingClass(Class clazz) {
    clazz
}

auxiliary enclosingClass(EObject object) {
    object?.eContainer?.enclosingClass
}

auxiliary enclosingProgram(Program program) {
    program
}

auxiliary enclosingProgram(EObject object) {
    object?.eContainer?.enclosingProgram
}

auxiliary findClass(QualifiedName name, EObject context) {
    var result = scopeProv.getScope(context, PepplPackage.eINSTANCE.class_Superclass)
        .getSingleElement(name)?.EObjectOrProxy as Class
    if(result != null)
        result
    else
        globalScopeProv.getScope(context.eResource, PepplPackage.eINSTANCE.class_Superclass, [true])
            .getSingleElement(name)?.EObjectOrProxy as Class
}


rule WBlock
    G |- Block b
from {
    for(s : b.statements) {
        G |- s
    }
}

rule WLocalVariable
    G |- LocalVariable v
from {
    v.initializer == null
    or
    G |- v.initializer <| v.type
}

rule WIfElse
    G |- IfElse ifElse
from {
    G |- ifElse.^condition : booleanType
    G |- ifElse.thenPart
    
    ifElse.elsePart == null
    or
    G |- ifElse.elsePart
}

rule WWhileLoop
    G |- WhileLoop l
from {
    G |- l.^condition : booleanType
    G |- l.body
}

rule WReturn
    G |- Return r
from {
    G |- r.expr <| r.enclosingMethod.type
}

rule WExpressionStatement
    G |- ExpressionStatement s
from {
    G |- s.expr : var Type t
}

rule TAssignment
    G |- Assignment a : Type t
from {
    G |- a.left : var Type leftType
    G |= a.left
    G |- a.right <| leftType
    t = leftType
}

rule TBooleanExpression
    G |- BooleanExpression e : booleanType
from {
    G |- e.left  <| booleanType
    G |- e.right <| booleanType
}

rule TEqualityExpression
    G |- EqualityExpression e : booleanType
from {
    G |- e.left  : var Type leftType
    G |- e.right : var Type rightType
    
    G |- leftType <: rightType
    or
    G |- rightType <: leftType
    or
    fail
        error "Cannot compare " + leftType.stringRep + " to " + rightType.stringRep
        source e
}

rule TRelationalExpression
    G |- RelationalExpression e : booleanType
from {
    G |- e.left  : var Type leftType
    G |- e.right : var Type rightType
    
    {
        G |- leftType  <: intType
        G |- rightType <: intType
    }
    or
    {
        G |- leftType  <: charType
        G |- rightType <: charType
    }
    or
    fail
        error "Cannot compare " + leftType.stringRep + " to " + rightType.stringRep
        source e
}

rule TArithmeticExpression
    G |- ArithmeticExpression e : Type t
from {
    G |- e.left  : var Type leftType
    G |- e.right : var Type rightType
    
    {
        e.op == OpArithmetic.PLUS;
        val stringType = roleType(READONLY, findClass(stringClassName, e))
        
        G |- leftType <: stringType or G |- rightType <: stringType     
        t = stringType
    }
    or
    {
        G |- leftType  <: intType
        G |- rightType <: intType
        t = intType
    }
    or fail
        error "The operator + is undefined for the argument types "
            + leftType.stringRep + ", " + rightType.stringRep
        source e
}

rule TUnaryMinus
    G |- UnaryMinus m : intType
from {
    G |- m.expr <| intType
}

rule TUnaryNot
    G |- UnaryNot n : booleanType
from {
    G |- n.expr <| booleanType
}

rule TMemberAccess
    G |- MemberAccess a : Type t
from {
    G |- a.target : var Type targetType
    if(targetType instanceof RoleType) {
        val selector = a.selector
        switch(selector) {
            FieldSelector: {
                G |- targetType.role <! READONLY or fail
                    error "Role mismatch: Cannot access field of a "
                        + targetType.role.stringRep + " target"
                    source a.target
                var fieldType = selector.field.type
                switch(fieldType) {
                    PrimitiveType: { t = fieldType }
                    RoleType: {
                        val role = leastCommonSuperrole(targetType.role, fieldType.role)
                        t = roleType(role, fieldType.base)
                    }
                }
            }
            MethodSelector: {
                G |- targetType.role <! selector.method.thisRole or fail
                    error "Role mismatch: Cannot call method " + selector.method.stringRep
                        +" on a " + targetType.role.stringRep + " target"
                    source a.target
                G |- selector.args << selector.method.params.map[type] ~~ selector
                t = selector.method.type
            }
        }
    }
    else {
        fail
        error "Illegal target type for member access: " + targetType.stringRep
        source a.target
    }
}

rule TThis
    G |- This t : Type type
    error "Cannot refer to \"this\" in this context"
    source t
from {
    type = env(G, "this", RoleType)
}

axiom TVariableRef
    G |- VariableRef r : r.variable.type

rule TNew
    G |- New n : roleType(READWRITE, n.clazz)
from {
    n.clazz.allConstructors.filter[
        G |- n.args << params.map[type] ~~ n.clazz
    ].size == 1
}

rule TParenthesized
    G |- Parenthesized p : Type t
from {
    G |- p.expr : t
}

rule TStringLiteral
    G |- StringLiteral s : Type t
    error "String class is not defined"
    source s
from {
    val stringClass = findClass(stringClassName, s)
    stringClass != null
    t = roleType(READWRITE, stringClass)
}

axiom TNullLiteral
    G |- NullLiteral __ : nullType

axiom TIntLiteral
    G |- IntLiteral __ : intType

axiom TBooleanLiteral
    G |- BooleanLiteral __ : booleanType

axiom TCharLiteral
    G |- CharLiteral __ : charType


rule SubtypeExpression
    G |- Expression left <| Type right
from {
    G |- left : var Type leftType
    G |- leftType <: right
}

rule SubtypeRoleTypes
    G |- RoleType left <: RoleType right
from {
    G |- left.role <! right.role // Subrole
    G |- left.base <~ right.base // Subclass
}

rule SubtypePrimitiveTypes
    G |- PrimitiveType left <: PrimitiveType right
from {
    left.class == right.class
}

axiom SubtypeNull
    G |- Null __ <: ReferenceType ___

rule SubtypeGeneral
    G |- Type left <: Type right
from { fail }


rule Subrole
    G |- Role left <! Role right
from {
    left.value <= right.value
}

rule Subclass
    G |- Class left <~ Class right
from {
    left == right || strictSuperclasses(left).contains(right)
}

rule SubtypeSequence
    G |- List<Expression> expressions << List<Type> types ~~ EObject src
from {
    expressions.size >= types.size or fail
        error "Too few arguments"
        source src
    expressions.size == types.size or fail
        error "Too many arguments"
        source src
    
    var i = expressions.iterator
    for(t : types) {
        G |- i.next <| t
    }
}

rule AVariableRef
    G |= VariableRef r
    error "Cannot assign to a value"
    source r
from {
    r.variable.kind == VAR
}

rule AMemberAccess
    G |= MemberAccess a
from {
    a.selector instanceof FieldSelector
    (a.selector as FieldSelector).field.kind == VAR or fail
        error "Cannot assign to a value field" source a
    
    G |- a.target : var RoleType type
    G |- type.role <! READWRITE or fail
        error "Cannot assign to field of " + type.role + " object" source a
}

rule AExpression
    G |= Expression __
from { fail }


checkrule CheckStatements for
    Statement s
from {
    val class = s.enclosingClass
    if(class == null) {
        // Main block
        empty |- s
    }
    else {
        // Method
        val thisType = roleType(READWRITE, class)
        "this" <- thisType |- s
    }
}

checkrule CheckObjectExists for
    Class c
from {
    c.superclass != null || findClass(objectClassName, c) != null or fail
        error "Object class is not defined"
        source c
        feature PepplPackage.eINSTANCE.class_Name
}