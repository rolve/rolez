import ch.trick17.peppl.lang.peppl.ArithmeticExpr
import ch.trick17.peppl.lang.peppl.Assignment
import ch.trick17.peppl.lang.peppl.Block
import ch.trick17.peppl.lang.peppl.BooleanExpr
import ch.trick17.peppl.lang.peppl.BooleanLiteral
import ch.trick17.peppl.lang.peppl.Cast
import ch.trick17.peppl.lang.peppl.CharLiteral
import ch.trick17.peppl.lang.peppl.Class
import ch.trick17.peppl.lang.peppl.EqualityExpr
import ch.trick17.peppl.lang.peppl.Expr
import ch.trick17.peppl.lang.peppl.ExprStmt
import ch.trick17.peppl.lang.peppl.FieldSelector
import ch.trick17.peppl.lang.peppl.IfStmt
import ch.trick17.peppl.lang.peppl.IntLiteral
import ch.trick17.peppl.lang.peppl.LocalVarDecl
import ch.trick17.peppl.lang.peppl.MemberAccess
import ch.trick17.peppl.lang.peppl.MethodSelector
import ch.trick17.peppl.lang.peppl.New
import ch.trick17.peppl.lang.peppl.Null
import ch.trick17.peppl.lang.peppl.NullLiteral
import ch.trick17.peppl.lang.peppl.OpArithmetic
import ch.trick17.peppl.lang.peppl.Parenthesized
import ch.trick17.peppl.lang.peppl.PepplPackage
import ch.trick17.peppl.lang.peppl.PrimitiveType
import ch.trick17.peppl.lang.peppl.ReferenceType
import ch.trick17.peppl.lang.peppl.RelationalExpr
import ch.trick17.peppl.lang.peppl.ReturnExpr
import ch.trick17.peppl.lang.peppl.ReturnNothing
import ch.trick17.peppl.lang.peppl.Role
import ch.trick17.peppl.lang.peppl.RoleType
import ch.trick17.peppl.lang.peppl.Stmt
import ch.trick17.peppl.lang.peppl.StringLiteral
import ch.trick17.peppl.lang.peppl.This
import ch.trick17.peppl.lang.peppl.Type
import ch.trick17.peppl.lang.peppl.UnaryMinus
import ch.trick17.peppl.lang.peppl.UnaryNot
import ch.trick17.peppl.lang.peppl.VarRef
import ch.trick17.peppl.lang.peppl.WhileLoop
import ch.trick17.peppl.lang.validation.AbstractPepplValidator
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.scoping.IGlobalScopeProvider

import static ch.trick17.peppl.lang.peppl.Role.*
import static ch.trick17.peppl.lang.peppl.VarKind.*
import ch.trick17.peppl.lang.peppl.Parameterized
import ch.trick17.peppl.lang.peppl.ElemWithArgs
import ch.trick17.peppl.lang.peppl.ClassRef
import ch.trick17.peppl.lang.peppl.SimpleClassRef
import ch.trick17.peppl.lang.peppl.GenericClassRef

system ch.trick17.peppl.lang.typesystem.PepplSystem

validatorExtends AbstractPepplValidator

inject extension PepplUtils __
inject IGlobalScopeProvider globalScopeProv

auxiliary {
    leastCommonSuperrole(Role r1, Role r2): Role
    actualSuperclass(Class clazz): Class
    strictSuperclasses(Class clazz): Set<Class> cached
    findClass(QualifiedName name, EObject context): Class
}

judgments {
    type      |- Expr e : output Type
    wellTyped |- Stmt s
    
    validArgs |- ElemWithArgs a << Parameterized p
    
    subtypeExpr |- Expr left <| Type right
        error "Type mismatch: " + left.type.value.stringRep + " is not a subtype of " + right.stringRep
        source left
    
    subtype  |- Type  left <: Type  right error "subtype" // Apparently, when no error message is specified, some "source" is taken, which can be very wrong...
    subrole  |- Role  left <! Role  right error "subrole"
    subclass |- ClassRef left <~ ClassRef right error "subclass"
    
    equalType |- Type left ~~ Type right
    
    assignable |= Expr e
        error "Cannot assign to " + e.stringRep
        source e
}

auxiliary leastCommonSuperrole(Role r1, Role r2) {
    if(r1.value > r2.value) r1 else r2 // Very simple so far
}

auxiliary actualSuperclass(Class c) {
    val objectClass = findClass(objectClassName, c)
    if(c == objectClass)
        null
    else if(c.superclass == null)
        objectClass
    else
        c.superclass
}

auxiliary strictSuperclasses(Class c) {
    val result = getAll(
        c,
        PepplPackage.eINSTANCE.class_Superclass,
        PepplPackage.eINSTANCE.class_Superclass,
        Class
    ).toSet
    
    val object = findClass(objectClassName, c)
    if(c != object && object != null)
        result.add(object)
    result
}

auxiliary findClass(QualifiedName name, EObject context) {
    globalScopeProv.getScope(context.eResource, PepplPackage.eINSTANCE.class_Superclass, [true])
        .getSingleElement(name)?.EObjectOrProxy as Class
}


rule TAssignment
    G |- Assignment a : Type t
from {
    G |- a.left : var Type leftType
    G |= a.left
    G |- a.right <| leftType
    t = leftType
}

rule TBooleanExpr
    G |- BooleanExpr e : booleanType
from {
    G |- e.left  <| booleanType
    G |- e.right <| booleanType
}

rule TEqualityExpr
    G |- EqualityExpr e : booleanType
from {
    G |- e.left  : var Type leftType
    G |- e.right : var Type rightType
    
    G |- leftType <: rightType
    or
    G |- rightType <: leftType
    or
    fail
        error "Cannot compare " + leftType.stringRep + " to " + rightType.stringRep
        source e
}

rule TRelationalExpr
    G |- RelationalExpr e : booleanType
from {
    G |- e.left  : var Type leftType
    G |- e.right : var Type rightType
    
    {
        G |- leftType  <: intType
        G |- rightType <: intType
    }
    or
    {
        G |- leftType  <: charType
        G |- rightType <: charType
    }
    or
    fail
        error "Cannot compare " + leftType.stringRep + " to " + rightType.stringRep
        source e
}

rule TArithmeticExpr
    G |- ArithmeticExpr e : Type t
from {
    G |- e.left  : var Type leftType
    G |- e.right : var Type rightType
    
    {
        e.op == OpArithmetic.PLUS;
        val stringType = roleType(READONLY, classRef(findClass(stringClassName, e)))
        
        G |- leftType <: stringType or G |- rightType <: stringType     
        t = stringType
    }
    or
    {
        G |- leftType  <: intType
        G |- rightType <: intType
        t = intType
    }
    or fail
        error "The operator + is undefined for the argument types "
            + leftType.stringRep + ", " + rightType.stringRep
        source e
}

rule TCast
    G |- Cast c : Type t
from {
    G |- c.expr : var Type exprType
    
    G |- exprType <: c.type // Upcasts are always fine
    or
    {
        c.type instanceof RoleType && exprType instanceof RoleType
        (exprType as RoleType).role == (c.type as RoleType).role
        G |- (c.type as RoleType).base <~ (exprType as RoleType).base
    }
    or fail
        error "Cannot cast " + exprType.stringRep + " to " + c.type.stringRep
        source c
    
    t = c.type
    // TODO: Allow coercion of primitive types?
}

rule TUnaryMinus
    G |- UnaryMinus m : intType
from {
    G |- m.expr <| intType
}

rule TUnaryNot
    G |- UnaryNot n : booleanType
from {
    G |- n.expr <| booleanType
}

rule TMemberAccess
    G |- MemberAccess a : Type t
from {
    G |- a.target : var Type targetType
    if(targetType instanceof RoleType) {
        val selector = a.selector
        switch(selector) {
            FieldSelector: {
                G |- targetType.role <! READONLY or fail
                    error "Role mismatch: Cannot access field of a "
                        + targetType.role.stringRep + " target"
                    source a.target
                var fieldType = selector.field.type
                switch(fieldType) {
                    PrimitiveType: { t = fieldType }
                    RoleType: {
                        val role = leastCommonSuperrole(targetType.role, fieldType.role)
                        t = roleType(role, fieldType.base)
                    }
                }
            }
            MethodSelector: {
                G |- targetType.role <! selector.method.thisRole or fail
                    error "Role mismatch: Cannot call method " + selector.method.stringRep
                        +" on a " + targetType.role.stringRep + " target"
                    source a.target
                G |- selector << selector.method
                t = selector.method.type
            }
        }
    }
    else {
        fail
        error "Illegal target type for member access: " + targetType.stringRep
        source a.target
    }
}

rule TThis
    G |- This t : Type type
    error "Cannot refer to \"this\" in this context"
    source t
from {
    type = env(G, "this", RoleType)
}

axiom TVarRef
    G |- VarRef r : r.variable.type

rule TNew
    G |- New n : roleType(READWRITE, n.classRef)
from {
    n.classRef.clazz.allConstructors.filter[G |- n << it].size == 1
    // TODO: use same rules as for methods
}

rule TParenthesized
    G |- Parenthesized p : Type t
from {
    G |- p.expr : t
}

rule TStringLiteral
    G |- StringLiteral s : Type t
    error "String class is not defined"
    source s
from {
    val stringClass = findClass(stringClassName, s)
    stringClass != null
    t = roleType(READWRITE, classRef(stringClass))
}

axiom TNullLiteral
    G |- NullLiteral __ : nullType

axiom TIntLiteral
    G |- IntLiteral __ : intType

axiom TBooleanLiteral
    G |- BooleanLiteral __ : booleanType

axiom TCharLiteral
    G |- CharLiteral __ : charType


rule WBlock
    G |- Block b
from {
    for(s : b.stmts) {
        G |- s
    }
}

rule WLocalVarDecl
    G |- LocalVarDecl d
from {
    d.initializer == null
    or
    G |- d.initializer <| d.variable.type
}

rule WIfStmt
    G |- IfStmt ifStmt
from {
    G |- ifStmt.^condition <| booleanType
    G |- ifStmt.thenPart
    
    ifStmt.elsePart == null
    or
    G |- ifStmt.elsePart
}

rule WWhileLoop
    G |- WhileLoop l
from {
    G |- l.^condition <| booleanType
    G |- l.body
}

axiom WReturnNothing
    G |- ReturnNothing _

rule WReturnExpr
    G |- ReturnExpr r
from {
    G |- r.expr <| r.enclosingMethod.type
}

rule WExprStmt
    G |- ExprStmt s
from {
    G |- s.expr : var Type t
}


rule ValidArgs
    G |- ElemWithArgs a << Parameterized p
from {
    a.args.size >= p.params.size or fail
        error "Too few arguments"
        source a
    a.args.size == p.params.size or fail
        error "Too many arguments"
        source a
    
    val i = a.args.iterator
    for(t : p.params.map[type]) {
        G |- i.next <| t
    }
}


rule SubtypeExpr
    G |- Expr left <| Type right
from {
    G |- left : var Type leftType
    G |- leftType <: right
}


rule SubtypeRoleTypes
    G |- RoleType left <: RoleType right
from {
    G |- left.role <! right.role // Subrole
    G |- left.base <~ right.base // Subclass
}

rule SubtypePrimitiveTypes
    G |- PrimitiveType left <: PrimitiveType right
from {
    left.class == right.class
}

axiom SubtypeNull
    G |- Null __ <: ReferenceType ___

rule SubtypeGeneral
    G |- Type left <: Type right
from { fail }


rule Subrole
    G |- Role left <! Role right
from {
    left.value <= right.value
}


rule SubclassSimple
    G |- SimpleClassRef left <~ SimpleClassRef right
from {
    left.clazz == right.clazz || strictSuperclasses(left.clazz).contains(right.clazz)
}

rule SubclassGeneric
    G |- GenericClassRef left <~ GenericClassRef right
from {
    left.clazz == right.clazz || strictSuperclasses(left.clazz).contains(right.clazz)
    G |- left.typeArg ~~ right.typeArg
}

rule SubclassGeneral
    G |- ClassRef left <~ ClassRef right
from { fail }

rule EqualTypePrimitiveTypes
    G |- PrimitiveType left ~~ PrimitiveType right
from {
    left.class == right.class
}

axiom EqualTypeNull
    G |- Null left ~~ Null right

rule EqualTypeRoleTypes
    G |- RoleType left ~~ RoleType right
from {
    left.role == right.role
    left.base.clazz == right.base.clazz // Is this correct?
    left.base instanceof GenericClassRef == right.base instanceof GenericClassRef
    
    left.base instanceof SimpleClassRef
    or
    G |- (left.base as GenericClassRef).typeArg ~~ (right.base as GenericClassRef).typeArg
}

rule EqualTypeGeneral
    G |- Type left ~~ Type right
from { fail }


rule AVarRef
    G |= VarRef r
    error "Cannot assign to a value"
    source r
from {
    r.variable.kind == VAR
}

rule AMemberAccess
    G |= MemberAccess a
from {
    a.selector instanceof FieldSelector
    (a.selector as FieldSelector).field.kind == VAR or fail
        error "Cannot assign to a value field" source a
    
    G |- a.target : var RoleType type
    G |- type.role <! READWRITE or fail
        error "Cannot assign to field of " + type.role + " object" source a
}

rule AExpr
    G |= Expr __
from { fail }


checkrule CheckStmts for
    Stmt s // Checked for all stmts individually, to get multiple error markers
from {
    val class = s.enclosingClass
    if(class == null) {
        // Main block
        empty |- s
    }
    else {
        // Method or constructor
        val thisType = roleType(READWRITE, classRef(class))
        "this" <- thisType |- s
    }
}