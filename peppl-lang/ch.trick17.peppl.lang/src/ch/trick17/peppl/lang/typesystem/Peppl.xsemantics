import ch.trick17.peppl.lang.peppl.ArithmeticExpression
import ch.trick17.peppl.lang.peppl.Assignment
import ch.trick17.peppl.lang.peppl.Block
import ch.trick17.peppl.lang.peppl.BooleanExpression
import ch.trick17.peppl.lang.peppl.BooleanLiteral
import ch.trick17.peppl.lang.peppl.CharLiteral
import ch.trick17.peppl.lang.peppl.Class
import ch.trick17.peppl.lang.peppl.EqualityExpression
import ch.trick17.peppl.lang.peppl.Expression
import ch.trick17.peppl.lang.peppl.ExpressionStatement
import ch.trick17.peppl.lang.peppl.FieldAccess
import ch.trick17.peppl.lang.peppl.IfElse
import ch.trick17.peppl.lang.peppl.IntLiteral
import ch.trick17.peppl.lang.peppl.LocalVariable
import ch.trick17.peppl.lang.peppl.Method
import ch.trick17.peppl.lang.peppl.MethodInvoke
import ch.trick17.peppl.lang.peppl.New
import ch.trick17.peppl.lang.peppl.NullLiteral
import ch.trick17.peppl.lang.peppl.OpArithmetic
import ch.trick17.peppl.lang.peppl.Parenthesized
import ch.trick17.peppl.lang.peppl.PepplPackage
import ch.trick17.peppl.lang.peppl.PrimitiveType
import ch.trick17.peppl.lang.peppl.Program
import ch.trick17.peppl.lang.peppl.RelationalExpression
import ch.trick17.peppl.lang.peppl.Return
import ch.trick17.peppl.lang.peppl.Role
import ch.trick17.peppl.lang.peppl.RoleType
import ch.trick17.peppl.lang.peppl.Statement
import ch.trick17.peppl.lang.peppl.StringLiteral
import ch.trick17.peppl.lang.peppl.This
import ch.trick17.peppl.lang.peppl.Type
import ch.trick17.peppl.lang.peppl.UnaryMinus
import ch.trick17.peppl.lang.peppl.UnaryNot
import ch.trick17.peppl.lang.peppl.VariableRef
import ch.trick17.peppl.lang.peppl.WhileLoop
import ch.trick17.peppl.lang.validation.AbstractPepplValidator
import java.util.List
import java.util.Set
import org.eclipse.emf.ecore.EObject

import static ch.trick17.peppl.lang.peppl.Role.*
import static ch.trick17.peppl.lang.peppl.VarKind.*

system ch.trick17.peppl.lang.typesystem.PepplSystem

validatorExtends AbstractPepplValidator

inject extension PepplTypeUtils typeUtils 

auxiliary {
    leastCommonSuperrole(Role r1, Role r2): Role
    strictSuperclasses(Class clazz): Set<Class> cached
    getEnclosingMethod(EObject object): Method
    getEnclosingClass(EObject object): Class
    getEnclosingProgram(EObject object): Program
    findClass(String name, Program program): Class
}

judgments {
    type      |- Expression expr : output Type
    wellTyped |- Statement s
    
    subtypeSequence   |- List<Expression> expressions << List<Type> types
    subtypeExpression |- Expression left              <| Type right
        error "Type mismatch: " + left.type.value.stringRep + " is not a subtype of " + right.stringRep
        source left
    
    subtype  |- Type  left <: Type  right error "subtype" // Apparently, when no error message is specified, some "source" is taken, which can be very wrong...
    subrole  |- Role  left <! Role  right error "subrole"
    subclass |- Class left <~ Class right error "subclass"
    
    assignable |= Expression expr
        error "Cannot assign to " + expr.stringRep
        source expr
}

auxiliary leastCommonSuperrole(Role r1, Role r2) {
    if(r1.value > r2.value) r1 else r2 // Very simple so far
}

auxiliary strictSuperclasses(Class clazz) {
    val result = getAll(
        clazz,
        PepplPackage.eINSTANCE.class_Superclass,
        PepplPackage.eINSTANCE.class_Superclass,
        Class
    ).toSet
    
    val object = findClass("Object", clazz.enclosingProgram)
    if(clazz != object && object != null)
        result.add(object)
    result
}

auxiliary getEnclosingMethod(Method method) {
    method
}

auxiliary getEnclosingMethod(EObject object) {
    object?.eContainer?.enclosingMethod
}

auxiliary getEnclosingClass(Class clazz) {
    clazz
}

auxiliary getEnclosingClass(EObject object) {
    object?.eContainer?.enclosingClass
}

auxiliary getEnclosingProgram(Program program) {
    program
}

auxiliary getEnclosingProgram(EObject object) {
    object?.eContainer?.enclosingProgram
}

auxiliary findClass(String className, Program program) {
    program.elements.filter(Class).findFirst[name==className]
}


rule WBlock
    G |- Block b
from {
    for(s : b.statements) {
        G |- s
    }
}

rule WLocalVariable
    G |- LocalVariable v
from {
    v.initializer == null
    or
    G |- v.initializer <| v.type
}

rule WIfElse
    G |- IfElse ifElse
from {
    G |- ifElse.^condition : booleanType
    G |- ifElse.thenPart
    
    ifElse.elsePart == null
    or
    G |- ifElse.elsePart
}

rule WWhileLoop
    G |- WhileLoop l
from {
    G |- l.^condition : booleanType
    G |- l.body
}

rule WReturn
    G |- Return r
from {
    G |- r.expr <| r.enclosingMethod.type
}

rule WExpressionStatement
    G |- ExpressionStatement s
from {
    G |- s.expr : var Type t
}


rule TAssignment
    G |- Assignment a : Type t
from {
    G |= a.left
    G |- a.left : var Type leftType
    G |- a.right <| leftType
    t = leftType
}

rule TBooleanExpression
    G |- BooleanExpression e : booleanType
from {
    G |- e.left  <| booleanType
    G |- e.right <| booleanType
}

rule TEqualityExpression
    G |- EqualityExpression e : booleanType
from {
    G |- e.left  : var Type leftType
    G |- e.right : var Type rightType
    
    G |- leftType <: rightType
    or
    G |- rightType <: leftType
    or
    fail
        error "Cannot compare " + leftType.stringRep + " to " + rightType.stringRep
        source e
}

rule TRelationalExpression
    G |- RelationalExpression e : booleanType
from {
    G |- e.left  : var Type leftType
    G |- e.right : var Type rightType
    
    {
        G |- leftType  <: intType
        G |- rightType <: intType
    }
    or
    {
        G |- leftType  <: charType
        G |- rightType <: charType
    }
    or
    fail
        error "Cannot compare " + leftType.stringRep + " to " + rightType.stringRep
        source e
}

rule TArithmeticExpression
    G |- ArithmeticExpression e : Type t
from {
    G |- e.left  : var Type leftType
    G |- e.right : var Type rightType
    
    {
        e.op == OpArithmetic.PLUS;
        val stringType = roleType(READONLY, findClass("String", e.enclosingProgram))
        
        G |- leftType <: stringType or G |- rightType <: stringType     
        t = stringType
    }
    or
    {
        G |- leftType  <: intType
        G |- rightType <: intType
        t = intType
    }
    or fail
        error "The operator + is undefined for the argument types "
            + leftType.stringRep + ", " + rightType.stringRep
        source e
}

rule TUnaryMinus
    G |- UnaryMinus m : intType
from {
    G |- m.expr <| intType
}

rule TUnaryNot
    G |- UnaryNot n : booleanType
from {
    G |- n.expr <| booleanType
}

rule TFieldAccess
    G |- FieldAccess a : Type t
from {
    G |- a.target : var RoleType targetType
    var fieldType = a.field.type
    switch(fieldType) {
        PrimitiveType: { t = fieldType }
        RoleType: {
            var role = leastCommonSuperrole(targetType.role, fieldType.role)
            t = roleType(role, fieldType.base)
        }
    }
}

rule TMethodInvoke
    G |- MethodInvoke i : i.method.type
from {
    G |- i.target : var RoleType targetType
    G |- i.args << i.method.params.map[type]
}

rule TThis
    G |- This t : Type type
    error "Cannot refer to \"this\" in this context"
    source t
from {
    type = env(G, "this", RoleType)
}

axiom TVariableRef
    G |- VariableRef r : r.variable.type

rule TNew
    G |- New n : roleType(READWRITE, n.clazz)
from {
    n.clazz.constructors.filter[
        G |- n.args << params.map[type]
    ].size == 1
}

rule TParenthesized
    G |- Parenthesized p : Type t
from {
    G |- p.expr : t
}

rule TStringLiteral
    G |- StringLiteral s : Type t
    error "String class is not defined"
    source s
from {
    val stringClass = findClass("String", s.enclosingProgram)
    stringClass != null
    t = roleType(READWRITE, stringClass)
}

axiom TNullLiteral
    G |- NullLiteral __ : nullType

axiom TIntLiteral
    G |- IntLiteral __ : intType

axiom TBooleanLiteral
    G |- BooleanLiteral __ : booleanType

axiom TCharLiteral
    G |- CharLiteral __ : charType


rule SubtypeExpression
    G |- Expression left <| Type right
from {
    G |- left : var Type leftType
    G |- leftType <: right
}

rule SubtypeRoleTypes
    G |- RoleType left <: RoleType right
from {
    G |- left.role <! right.role // Subrole
    G |- left.base <~ right.base // Subclass
}

rule SubtypePrimitiveTypes
    G |- PrimitiveType left <: PrimitiveType right
from {
    left.class == right.class
}

rule SubtypeGeneral
    G |- Type left <: Type right
from { fail }


rule Subrole
    G |- Role left <! Role right
from {
    left.value <= right.value
}

rule Subclass
    G |- Class left <~ Class right
from {
    left == right || strictSuperclasses(left).contains(right)
}

rule SubtypeSequence
    G |- List<Expression> expressions << List<Type> types
from {
    expressions.size >= types.size or fail
        error "Too few arguments"
    expressions.size == types.size or fail
        error "Too many arguments"
    
    var i = expressions.iterator
    for(t : types) {
        G |- i.next <| t
    }
}

rule AVariableRef
    G |= VariableRef r
    error "Cannot assign to a value"
    source r
from {
    r.variable.kind == VAR
}

rule AFieldAccess
    G |= FieldAccess a
from {
    a.field.kind == VAR or fail
        error "Cannot assign to a value field" source a
    
    G |- a.target : var RoleType type
    G |- type.role <! READWRITE or fail
        error "Cannot assign to field of " + type.role + " object" source a
}

rule AExpression
    G |= Expression __
from { fail }


checkrule CheckStatements for
    Statement s
from {
    val class = s.enclosingClass
    if(class == null) {
        // Main block
        empty |- s
    }
    else {
        // Method
        val thisType = roleType(READWRITE, class)
        "this" <- thisType |- s
    }
}

checkrule CheckObjectExists for
    Class c
from {
    c.superclass != null || findClass("Object", c.enclosingProgram) != null or fail
        error "Object class is not defined"
        source c
        feature PepplPackage.eINSTANCE.class_Name
}