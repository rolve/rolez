import ch.trick17.peppl.lang.peppl.ArithmeticExpr
import ch.trick17.peppl.lang.peppl.Assignment
import ch.trick17.peppl.lang.peppl.Block
import ch.trick17.peppl.lang.peppl.BooleanExpr
import ch.trick17.peppl.lang.peppl.BooleanLiteral
import ch.trick17.peppl.lang.peppl.Cast
import ch.trick17.peppl.lang.peppl.CharLiteral
import ch.trick17.peppl.lang.peppl.Class
import ch.trick17.peppl.lang.peppl.ClassRef
import ch.trick17.peppl.lang.peppl.Argumented
import ch.trick17.peppl.lang.peppl.EqualityExpr
import ch.trick17.peppl.lang.peppl.Expr
import ch.trick17.peppl.lang.peppl.ExprStmt
import ch.trick17.peppl.lang.peppl.FieldSelector
import ch.trick17.peppl.lang.peppl.GenericClassRef
import ch.trick17.peppl.lang.peppl.IfStmt
import ch.trick17.peppl.lang.peppl.IntLiteral
import ch.trick17.peppl.lang.peppl.LocalVarDecl
import ch.trick17.peppl.lang.peppl.MemberAccess
import ch.trick17.peppl.lang.peppl.MethodSelector
import ch.trick17.peppl.lang.peppl.New
import ch.trick17.peppl.lang.peppl.Null
import ch.trick17.peppl.lang.peppl.NullLiteral
import ch.trick17.peppl.lang.peppl.OpArithmetic
import ch.trick17.peppl.lang.peppl.ParameterizedBody
import ch.trick17.peppl.lang.peppl.Parenthesized
import ch.trick17.peppl.lang.peppl.PrimitiveType
import ch.trick17.peppl.lang.peppl.ReferenceType
import ch.trick17.peppl.lang.peppl.RelationalExpr
import ch.trick17.peppl.lang.peppl.ReturnExpr
import ch.trick17.peppl.lang.peppl.ReturnNothing
import ch.trick17.peppl.lang.peppl.Role
import ch.trick17.peppl.lang.peppl.RoleType
import ch.trick17.peppl.lang.peppl.SimpleClassRef
import ch.trick17.peppl.lang.peppl.Stmt
import ch.trick17.peppl.lang.peppl.StringLiteral
import ch.trick17.peppl.lang.peppl.This
import ch.trick17.peppl.lang.peppl.Type
import ch.trick17.peppl.lang.peppl.UnaryMinus
import ch.trick17.peppl.lang.peppl.UnaryNot
import ch.trick17.peppl.lang.peppl.VarKind
import ch.trick17.peppl.lang.peppl.VarRef
import ch.trick17.peppl.lang.peppl.WhileLoop
import ch.trick17.peppl.lang.validation.AbstractPepplValidator
import java.util.Set

import static ch.trick17.peppl.lang.peppl.PepplPackage.Literals.*
import static ch.trick17.peppl.lang.peppl.Role.*
import ch.trick17.peppl.lang.peppl.Start

system ch.trick17.peppl.lang.typesystem.PepplSystem

validatorExtends AbstractPepplValidator

inject extension PepplUtils _

auxiliary {
    leastCommonSuperrole(Role r1, Role r2): Role
    strictSuperclasses(Class clazz): Set<Class> cached
}

judgments {
    type      |- Expr e : output Type
    wellTyped |- Stmt s
    
    validArgs |- Argumented a << ParameterizedBody p
    
    subtypeExpr |- Expr left <| Type right
        error "Type mismatch: " + left.type.value.stringRep + " is not a subtype of " + right.stringRep
        source left
    
    subtype  |- Type  left <: Type  right error "subtype" // Apparently, an error message is necessary for sensible error message selection
    subrole  |- Role  left <! Role  right error "subrole"
    subclass |- ClassRef left <~ ClassRef right error "subclass"
    
    equalType |- Type left ~~ Type right error "equal type"
    
    assignable |= Expr e
        error "Cannot assign to " + e.stringRep
        source e
}

auxiliary leastCommonSuperrole(Role r1, Role r2) {
    if(r1.value > r2.value) r1 else r2 // Very simple so far
}

auxiliary strictSuperclasses(Class c) {
    val result = getAll(
        c,
        CLASS__SUPERCLASS,
        CLASS__SUPERCLASS,
        Class
    ).toSet
    
    val object = findClass(objectClassName, c)
    if(c != object && object != null)
        result.add(object)
    result
}


rule TAssignment
    G |- Assignment a : Type t
from {
    G |- a.left : var Type leftType
    G |= a.left
    G |- a.right <| leftType
    t = leftType
}

rule TBooleanExpr
    G |- BooleanExpr e : booleanType
from {
    G |- e.left  <| booleanType
    G |- e.right <| booleanType
}

rule TEqualityExpr
    G |- EqualityExpr e : booleanType
from {
    G |- e.left  : var Type leftType
    G |- e.right : var Type rightType
    
    G |- leftType <: rightType
    or
    G |- rightType <: leftType
    or
    fail
        error "Cannot compare " + leftType.stringRep + " to " + rightType.stringRep
        source e
}

rule TRelationalExpr
    G |- RelationalExpr e : booleanType
from {
    G |- e.left  : var Type leftType
    G |- e.right : var Type rightType
    
    {
        G |- leftType  <: intType
        G |- rightType <: intType
    }
    or
    {
        G |- leftType  <: charType
        G |- rightType <: charType
    }
    or
    fail
        error "Cannot compare " + leftType.stringRep + " to " + rightType.stringRep
        source e
}

rule TArithmeticExpr
    G |- ArithmeticExpr e : Type t
from {
    G |- e.left  : var Type leftType
    G |- e.right : var Type rightType
    
    {
        e.op == OpArithmetic.PLUS;
        val stringType = roleType(READONLY, classRef(findClass(stringClassName, e)))
        
        G |- leftType <: stringType or G |- rightType <: stringType     
        t = stringType
    }
    or
    {
        G |- leftType  <: intType
        G |- rightType <: intType
        t = intType
    }
    or fail
        error "The operator + is undefined for the argument types "
            + leftType.stringRep + ", " + rightType.stringRep
        source e
}

rule TCast
    G |- Cast c : Type t
from {
    G |- c.expr : var Type exprType
    
    G |- exprType <: c.type // Upcasts are always fine
    or
    {
        // Downcasts only allowed if role stays the same and of there is a subclass relation
        c.type instanceof RoleType && exprType instanceof RoleType
        (exprType as RoleType).role == (c.type as RoleType).role
        G |- (c.type as RoleType).base <~ (exprType as RoleType).base
    }
    or fail
        error "Cannot cast " + exprType.stringRep + " to " + c.type.stringRep
        source c
    
    t = c.type
    // TODO: Allow coercion of primitive types?
}

rule TUnaryMinus
    G |- UnaryMinus m : intType
from {
    G |- m.expr <| intType
}

rule TUnaryNot
    G |- UnaryNot n : booleanType
from {
    G |- n.expr <| booleanType
}

rule TMemberAccess
    G |- MemberAccess a : Type t
from {
    G |- a.target : var Type targetType
    if(targetType instanceof RoleType) {
        val selector = a.selector
        switch(selector) {
            FieldSelector: {
                G |- targetType.role <! READONLY or fail
                    error "Role mismatch: Cannot access field of a "
                        + targetType.role.stringRep + " target"
                    source a.target
                var fieldType = selector.field.type
                switch(fieldType) {
                    PrimitiveType: { t = fieldType }
                    RoleType: {
                        val role = leastCommonSuperrole(targetType.role, fieldType.role)
                        t = roleType(role, fieldType.base)
                    }
                }
            }
            MethodSelector: {
                G |- targetType.role <! selector.method.thisRole or fail
                    error "Role mismatch: Cannot call method " + selector.method.stringRep
                        +" on a " + targetType.role.stringRep + " target"
                    source a.target
                t = selector.method.type
            }
        }
    }
    else {
        fail
        error "Illegal target type for member access: " + targetType.stringRep
        source a.target
    }
}

rule TThis
    G |- This t : Type type
    error "Cannot refer to \"this\" in this context"
    source t
from {
    type = env(G, "this", RoleType)
}

axiom TVarRef
    G |- VarRef r : r.variable.type

rule TNew
    G |- New n : roleType(READWRITE, n.classRef)
from {
    val maxSpecific = n.classRef.clazz.allConstructors.maximallySpecific(n)
    maxSpecific.size == 1 or fail
        error
            if(maxSpecific.size == 0) "No suitable constructor for given argument types"
            else "Constructor call is ambiguous"
        source n
    // TODO: Can constructors somehow be linked?
}

rule TStart
    G |- Start s : Type t
    error "Task class is not defined"
    source s
from {
    val taskClass = findClass(taskClassName, s)
    taskClass != null
    G |- s << s.task
    t = roleType(PURE, classRef(taskClass, s.task.type))
}

rule TParenthesized
    G |- Parenthesized p : Type t
from {
    G |- p.expr : t
}

rule TStringLiteral
    G |- StringLiteral s : Type t
    error "String class is not defined"
    source s
from {
    val stringClass = findClass(stringClassName, s)
    stringClass != null
    t = roleType(READWRITE, classRef(stringClass))
}

axiom TNullLiteral
    G |- NullLiteral __ : nullType

axiom TIntLiteral
    G |- IntLiteral __ : intType

axiom TBooleanLiteral
    G |- BooleanLiteral __ : booleanType

axiom TCharLiteral
    G |- CharLiteral __ : charType


rule WBlock
    G |- Block b
from {
    for(s : b.stmts) {
        G |- s
    }
}

rule WLocalVarDecl
    G |- LocalVarDecl d
from {
    d.initializer == null
    or
    G |- d.initializer <| d.variable.type
}

rule WIfStmt
    G |- IfStmt ifStmt
from {
    G |- ifStmt.^condition <| booleanType
    G |- ifStmt.thenPart
    
    ifStmt.elsePart == null
    or
    G |- ifStmt.elsePart
}

rule WWhileLoop
    G |- WhileLoop l
from {
    G |- l.^condition <| booleanType
    G |- l.body
}

axiom WReturnNothing
    G |- ReturnNothing _

rule WReturnExpr
    G |- ReturnExpr r
from {
    G |- r.expr <| r.enclosingMethod.type
}

rule WExprStmt
    G |- ExprStmt s
from {
    G |- s.expr : var Type t
}


rule ValidArgs
    G |- Argumented a << ParameterizedBody p
from {
    a.args.size >= p.params.size or fail
        error "Too few arguments"
        source a
    a.args.size == p.params.size or fail
        error "Too many arguments"
        source a
    
    val i = a.args.iterator
    for(t : p.params.map[type]) {
        G |- i.next <| t
    }
}


rule SubtypeExpr
    G |- Expr left <| Type right
from {
    G |- left : var Type leftType
    G |- leftType <: right
}


rule SubtypeRoleTypes
    G |- RoleType left <: RoleType right
from {
    G |- left.role <! right.role // Subrole
    G |- left.base <~ right.base // Subclass
}

rule SubtypePrimitiveTypes
    G |- PrimitiveType left <: PrimitiveType right
from {
    left.class == right.class
}

axiom SubtypeNull
    G |- Null __ <: ReferenceType ___

rule SubtypeGeneral
    G |- Type left <: Type right
from { fail }


rule Subrole
    G |- Role left <! Role right
from {
    left.value <= right.value
}


rule SubclassSimple
    G |- SimpleClassRef left <~ SimpleClassRef right
from {
    left.clazz == right.clazz || strictSuperclasses(left.clazz).contains(right.clazz)
}

rule SubclassGeneric
    G |- GenericClassRef left <~ GenericClassRef right
from {
    left.clazz == right.clazz || strictSuperclasses(left.clazz).contains(right.clazz)
    G |- left.typeArg ~~ right.typeArg
}

rule SubclassGeneral
    G |- ClassRef left <~ ClassRef right
from { fail }

rule EqualTypePrimitiveTypes
    G |- PrimitiveType left ~~ PrimitiveType right
from {
    left.class == right.class
}

axiom EqualTypeNull
    G |- Null left ~~ Null right

rule EqualTypeRoleTypes
    G |- RoleType left ~~ RoleType right
from {
    left.role == right.role
    left.base.clazz == right.base.clazz // Is this correct?
    left.base instanceof GenericClassRef == right.base instanceof GenericClassRef
    
    left.base instanceof SimpleClassRef
    or
    G |- (left.base as GenericClassRef).typeArg ~~ (right.base as GenericClassRef).typeArg
}

rule EqualTypeGeneral
    G |- Type left ~~ Type right
from { fail }


rule AVarRef
    G |= VarRef r
    error "Cannot assign to a value"
    source r
from {
    r.variable.kind == VarKind.VAR
}

rule AMemberAccess
    G |= MemberAccess a
from {
    a.selector instanceof FieldSelector
    (a.selector as FieldSelector).field.kind == VarKind.VAR or fail
        error "Cannot assign to a value field" source a
    
    G |- a.target : var RoleType type
    G |- type.role <! READWRITE or fail
        error "Cannot assign to field of " + type.role + " object" source a
}

rule AExpr
    G |= Expr __
from { fail }


checkrule CheckStmt for
    Stmt s // Checked for all stmts individually, to get multiple error markers
from {
    val class = s.enclosingClass
    if(class == null) { // Task
        empty |- s
    }
    else { // Method or constructor
        val thisType = roleType(READWRITE, classRef(class))
        "this" <- thisType |- s
    }
}